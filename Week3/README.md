# Week 3
We discuss the Quantum Fourier Transform and applications, and . Reading is parts of Chap 5 and 6 of QCQI.
<br/><br/>
    We first discuss the Quantum Fourier transform and look at a nice compact form for it. This motivates a simple implementation of the transform and also proves that the transform is unitary(though that can be proved directly from the definition as well). We then discuss Phase estimation, which is a very clever way to compute the phase of a (unit modulus) eigenvalue of a unitary operator(its order must be a power of 2, though). We also analyse the performance of the algorithm and the probability of success. Finally we implement the algorithm in Qiskit. 
<br/><br/>
    Next, we look at Order finding. It solves the classic problem of finding the order of a number modulo another(if this was classically so trivial, a lot of IMO problems would have been much easier :) ) using phase-estimation of a well-chosen unitary operator. I wonder how they came up with that operator though, once you get some of its eigenvalues it makes a lot of sense, but how would someone come up with it in the first place? The order-finding algorithm uses an oracle that can compute powers of the unitary applied to a qubit register. It also uses phase-estimation as a subroutine and a bit of fraction manipulation as a classical subroutine at the end. Finally we get our order $r$ with high probability(with the probability of success of the phase-estimation subroutine). A clever point to note here is that we make use of the fact that the eigenvectors in question when weighted with a phase sum up to $|1\rangle$, so we needn't specifically prepare an eigenstate(which incidentally, would likely not even be possible since the eigenstate requires that you know $r$, or conversely, if it were possible, then we could possibly extract $r$ from it itself! - perhaps it is indeed possible to prepare it though, that's something to think about!). We implement this algorithm in Qiskit to find the order of various integers modulo $15$.
 <br/><br/>
    We then look at a nice application of the order-finding technique - Factoring numbers(the Shor algorithm). The key point to note is that for a composite number $n$, if you can find integers $x, r$ such that r is even, $x^r \equiv 1 \pmod n but x^{r/2} \not\equiv 1, -1 \pmod n$. Then note that $n$ divides $(x^{r/2} - 1)(x^{r/2} + 1)$ but does not fully divide any term(and hence cannot be coprime to any term)! So $\text{gcd}(x^{r/2} - 1, n)$ and $\text{gcd}(x^{r/2} + 1, n)$ serve as non-trivial factors of $n$, done! Now to look for $x$ and $r$. A theorem says that for integers $x$ coprime to $n$, their order modulo $n$ is usually even - can serve as $r$, we must just check that $x^{r/2}  + 1 \not\equiv 0 \pmod n$. And unsurprisingly, we use the order-finding slgorithm above as a subroutine to find the order $r$ of a randomly chosen comprime(to n) $x$. We implement this algorithm to factor $15$ in Qiskit.
    
One point to note. Order-finding requires us to implement the oracle for a specific unitary. The construction is non-trivial. Hence in this implementation we look at only a specific case of the general algorithm by fixing $n = 15$ and constructing the required unitary in this special case.
<br/><br/>
We then look at Quantum Searching using Grover's algorithm. Reading is parts of Chap 6 of QCQI. The geometric idea behind Grover's algorithm is simply superb, it was so so nice.
  A nice point: Using $\frac{|0\rangle - |1\rangle}{\sqrt{2}}$ as the target to an oracle(oracle($f(x)$) takes $|x\rangle|y\rangle \rightarrow |x\rangle|y \oplus f(x)\rangle$) is a good idea since it is an eigenvector (with eigenvalue $(-1)^{f(x)}$) of the oracle and so can be neglected from the analysis, just the $(-1)^{f(x)}$ factor is enough. This idea was used in Deutsch-Josza and came up again in Grover Search.
